<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chino&#39;s Workspace</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chinomars.github.io/"/>
  <updated>2020-02-11T16:21:15.106Z</updated>
  <id>https://chinomars.github.io/</id>
  
  <author>
    <name>Chino Mars</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>REPL技术分析——Python的交互式</title>
    <link href="https://chinomars.github.io/2020/02/12/REPL%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Python%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    <id>https://chinomars.github.io/2020/02/12/REPL%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Python%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F/</id>
    <published>2020-02-11T16:20:11.000Z</published>
    <updated>2020-02-11T16:21:15.106Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Python是一种解释型语言，通过解释器对代码进行逐行执行，一般的解释器也是这样实现，当然也存在一些优化方法，对代码进行JIT编译，提高执行速度。所以Python的REPL可以说是原生支持的。</p><p>Python语言有多种解释器，例如：</p><ul><li>CPython：C语言实现的Python解释器，一般情况下在Terminal中执行命令<code>python</code>，就会调用CPython解释器执行代码</li><li>PyPy：前面提到的通过JIT技术提升Python代码执行速度</li><li>IPython：Python的交互式解释器，底层也是通过调用CPython对代码进行解释执行</li></ul><p>回到主题REPL，我们可以以IPython为入口进行分析，进一步对CPython进行分析</p><h3 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h3><p>个人习惯，从源码出发分析。IPtyhon的github源码仓，<a href="https://github.com/ipython/ipython" target="_blank" rel="noopener">链接</a>，交互式开发的mainloop的代码在这个interactiveshell.py中，我们可以看到，IPython支持一个完整的代码块的交互式运行，采用异步的方式运行以保证一定的用户体验。一个完整的代码块，由用户输入，可以是一行完整的python代码，也可以是多行语法的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_run_cell</span><span class="params">(self, raw_cell:str, store_history:bool, silent:bool, shell_futures:bool)</span>:</span></span><br><span class="line">        <span class="string">"""Internal method to run a complete IPython cell."""</span></span><br><span class="line">        coro = self.run_cell_async(</span><br><span class="line">            raw_cell,</span><br><span class="line">            store_history=store_history,</span><br><span class="line">            silent=silent,</span><br><span class="line">            shell_futures=shell_futures,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># run_cell_async is async, but may not actually need an eventloop.</span></span><br><span class="line">        <span class="comment"># when this is the case, we want to run it using the pseudo_sync_runner</span></span><br><span class="line">        <span class="comment"># so that code can invoke eventloops (for example via the %run , and</span></span><br><span class="line">        <span class="comment"># `%paste` magic.</span></span><br><span class="line">        <span class="keyword">if</span> self.trio_runner:</span><br><span class="line">            runner = self.trio_runner</span><br><span class="line">        <span class="keyword">elif</span> self.should_run_async(raw_cell):</span><br><span class="line">            runner = self.loop_runner</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            runner = _pseudo_sync_runner</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> runner(coro)</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            info = ExecutionInfo(raw_cell, store_history, silent, shell_futures)</span><br><span class="line">            result = ExecutionResult(info)</span><br><span class="line">            result.error_in_exec = e</span><br><span class="line">            self.showtraceback(running_compiled_code=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>继续分析这个run_cell_async：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run_cell_async</span><span class="params">(self, raw_cell: str, store_history=False, silent=False, shell_futures=True)</span> -&gt; ExecutionResult:</span></span><br><span class="line">        info = ExecutionInfo(</span><br><span class="line">            raw_cell, store_history, silent, shell_futures)</span><br><span class="line">        result = ExecutionResult(info)</span><br><span class="line">...</span><br><span class="line">        <span class="comment"># If any of our input transformation (input_transformer_manager or</span></span><br><span class="line">        <span class="comment"># prefilter_manager) raises an exception, we store it in this variable</span></span><br><span class="line">        <span class="comment"># so that we can display the error after logging the input and storing</span></span><br><span class="line">        <span class="comment"># it in the history.</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cell = self.transform_cell(raw_cell)</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Store raw and processed history</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Display the exception if input processing failed.</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Our own compiler remembers the __future__ environment. If we want to</span></span><br><span class="line">        <span class="comment"># run code with a separate __future__ environment, use the default</span></span><br><span class="line">        <span class="comment"># compiler</span></span><br><span class="line">        compiler = self.compile <span class="keyword">if</span> shell_futures <span class="keyword">else</span> CachingCompiler()</span><br><span class="line">        _run_async = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">with</span> self.builtin_trap:</span><br><span class="line">            cell_name = self.compile.cache(cell, self.execution_count)</span><br><span class="line">            <span class="keyword">with</span> self.display_trap:</span><br><span class="line">                <span class="comment"># Compile to bytecode</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> sys.version_info &lt; (<span class="number">3</span>,<span class="number">8</span>) <span class="keyword">and</span> self.autoawait:</span><br><span class="line">                        <span class="keyword">if</span> _should_be_async(cell):</span><br><span class="line">                            <span class="comment"># the code AST below will not be user code: we wrap it</span></span><br><span class="line">                            <span class="comment"># in an `async def`. This will likely make some AST</span></span><br><span class="line">                            <span class="comment"># transformer below miss some transform opportunity and</span></span><br><span class="line">                            <span class="comment"># introduce a small coupling to run_code (in which we</span></span><br><span class="line">                            <span class="comment"># bake some assumptions of what _ast_asyncify returns.</span></span><br><span class="line">                            <span class="comment"># they are ways around (like grafting part of the ast</span></span><br><span class="line">                            <span class="comment"># later:</span></span><br><span class="line">                            <span class="comment">#    - Here, return code_ast.body[0].body[1:-1], as well</span></span><br><span class="line">                            <span class="comment">#    as last expression in  return statement which is</span></span><br><span class="line">                            <span class="comment">#    the user code part.</span></span><br><span class="line">                            <span class="comment">#    - Let it go through the AST transformers, and graft</span></span><br><span class="line">                            <span class="comment">#    - it back after the AST transform</span></span><br><span class="line">                            <span class="comment"># But that seem unreasonable, at least while we</span></span><br><span class="line">                            <span class="comment"># do not need it.</span></span><br><span class="line">                            code_ast = _ast_asyncify(cell, <span class="string">'async-def-wrapper'</span>)</span><br><span class="line">                            _run_async = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            code_ast = compiler.ast_parse(cell, filename=cell_name)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        code_ast = compiler.ast_parse(cell, filename=cell_name)</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># Apply AST transformations</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    code_ast = self.transform_ast(code_ast)</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment"># Execute the user code</span></span><br><span class="line">                interactivity = <span class="string">"none"</span> <span class="keyword">if</span> silent <span class="keyword">else</span> self.ast_node_interactivity</span><br><span class="line">                <span class="keyword">if</span> _run_async:</span><br><span class="line">                    interactivity = <span class="string">'async'</span></span><br><span class="line"></span><br><span class="line">                has_raised = <span class="keyword">await</span> self.run_ast_nodes(code_ast.body, cell_name,</span><br><span class="line">                       interactivity=interactivity, compiler=compiler, result=result)</span><br><span class="line">...</span><br><span class="line">                <span class="comment"># Reset this so later displayed values do not modify the</span></span><br><span class="line">                <span class="comment"># ExecutionResult</span></span><br><span class="line">                self.displayhook.exec_result = <span class="literal">None</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>我把一些异常处理的代码省略了，不关键的跳过。删除不关键的处理流程后我们可以分析下源码：</p><ul><li>首先是将cell代码块（raw_cell），执行历史（store_history），以及一些设置运行模式的参数（silent和shell_futures）来示例化成ExecutionInfo，然后将它塞到ExecutionResult这个方法中，做进一步的封装，方便后续进行执行过程中关键信息的存储</li><li><code>tramsform_cell</code>的工作主要是做一些行的分割以及其他处理，例如确保每一个输入cell最后有一个空行，这个也是编译器的常规操作，方便parsing的时候计算报错行号</li><li><code>_ast_asyncify</code>是一个异步方法，将输入cell（源码）解析为ast，同样其他两个分支都是将输入解析为ast，这里的分支是为了区分版本，解决版本兼容性。这里的<code>compiler</code>我们没有在IPython源码中找到定义，推测是CPython的封装，后续再分析</li><li><code>run_ast_nodes</code>也是调用了compiler的能力，下面我们就可以去CPython中进一步分析了</li></ul><p>IPython主要对CPython进行封装，将ast导入给CPython进行执行。并且，部分情况下并没有调用compiler封装的run_code方法，而是直接使用Python内置的exec()方法执行python代码，处理也比较简单。</p><h3 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h3><p>CPython是python解释器的c语言实现，也是Python的官方解释器。按照惯例我们还是从源码入手，cpython托管在github上，<a href="https://github.com/python/cpython" target="_blank" rel="noopener">项目链接</a>。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>首先从main函数出发，找到<code>Programs/python.c</code>中的main函数，在进入到repl loop之前，我们快速过一下执行流程。当然，对于c/c++项目而言，最万能的方式还是通过调试，一步一步地借助断点和查看调用栈来分析。在只关注一个具体的功能的时候，个人还是比较偏向于直接看源码，聚焦关键的函数。</p><p>执行流程：</p><ul><li><code>Programs/python.c:16 =&gt; Py_BytesMain</code></li><li><code>Modules/main.c:679 =&gt; pymain_main</code></li><li><code>Modules/main.c:627 Py_RunMain =&gt; pymain_run_python</code></li></ul><p>到pymain_run_python()函数，我们可以具体看一下这个函数里的构成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pymain_run_python(<span class="keyword">int</span> *exitcode)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;run_command) &#123;</span><br><span class="line">        *exitcode = pymain_run_command(<span class="built_in">config</span>-&gt;run_command, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;run_module) &#123;</span><br><span class="line">        *exitcode = pymain_run_module(<span class="built_in">config</span>-&gt;run_module, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (main_importer_path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *exitcode = pymain_run_module(<span class="string">L"__main__"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">config</span>-&gt;run_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *exitcode = pymain_run_file(<span class="built_in">config</span>, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *exitcode = pymain_run_stdin(<span class="built_in">config</span>, &amp;cf);</span><br><span class="line">    &#125;</span><br><span class="line">    pymain_repl(<span class="built_in">config</span>, &amp;cf, exitcode);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，通过函数最开始构建的运行环境配置（config），来决定后续的分支：</p><ul><li>run_command分支：调用<code>pymain_run_command()</code>函数，来执行命令</li><li>run_module分支：调用<code>pymain_run_module()</code>函数，运行一个python模块</li><li>run_filename分支：调用<code>pymain_run_file()</code>函数，运行一个python文件</li><li>其他：调用<code>pymain_run_stdin()</code>函数，来执行一个标准输入</li><li>最后：调用<code>pymain_repl()</code>函数，启动repl</li></ul><p>上述执行分支中，估计大家对于最后两个分支（<strong>其他</strong>和<strong>最后</strong>）会感到十分疑惑，看起来逻辑有重复，<strong>其他</strong>分支中，调用<code>pymain_run_stdin()</code>函数后，再启动repl。实际上最后两个分支最终调用的函数都是一样的：</p><ul><li><code>pymain_run_stdin()</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">pymain_run_stdin(PyConfig *<span class="built_in">config</span>, PyCompilerFlags *cf)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">run</span> = PyRun_AnyFileExFlags(<span class="built_in">stdin</span>, <span class="string">"&lt;stdin&gt;"</span>, <span class="number">0</span>, cf);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">run</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>pymain_repl()</code>：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pymain_repl(PyConfig *<span class="built_in">config</span>, PyCompilerFlags *cf, <span class="keyword">int</span> *exitcode)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="keyword">int</span> res = PyRun_AnyFileFlags(<span class="built_in">stdin</span>, <span class="string">"&lt;stdin&gt;"</span>, cf);</span><br><span class="line">    *exitcode = (res != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，在<code>pymain_repl()</code>中调用的<code>PyRun_AnyFileFlags()</code>，在<code>include/pythonrun.h</code>中定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyRun_AnyFileFlags(fp, name, flags) \</span></span><br><span class="line">    PyRun_AnyFileExFlags(fp, name, <span class="number">0</span>, flags)</span><br></pre></td></tr></table></figure><p>是一毛一样的呢。最终就执行到了我们的重头戏：<code>Python/pythonrun.c:91 PyRun_InteractiveLoopFlags()</code></p><h4 id="interactive-loop"><a href="#interactive-loop" class="headerlink" title="interactive loop"></a>interactive loop</h4><p><code>PyRun_InteractiveLoopFlags(stdin, &quot;&lt;stdin&gt;&quot;, 0, cf)</code>中，从<code>stdin</code>标准输入流中读取用户输入，进行执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">PyRun_InteractiveLoopFlags(FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename_str, PyCompilerFlags *flags)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; PyErr_Occurred()) &#123;</span><br><span class="line">...</span><br><span class="line">            PyErr_Print();</span><br><span class="line">            flush_io();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nomem_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret != E_EOF);</span><br><span class="line">    Py_DECREF(filename);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>PyRun_InteractiveOneObjectEx()</code>函数执行用户输入。</p><p>我们可以看到对于一个Python Object的执行流程如下：</p><ul><li><code>_PyUnicode_FromId</code>：造一个modulename</li><li><code>_PySys_GetObjectId</code>：从stdin中读取用户输入</li><li><code>PyImport_AddModuleObject</code>：加载import模块</li><li><code>run_mod</code>：运行module</li></ul><p><code>run_mod()</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">run_mod(mod_ty mod, PyObject *filename, PyObject *globals, PyObject *locals,</span><br><span class="line">            PyCompilerFlags *flags, PyArena *arena)</span><br><span class="line">&#123;</span><br><span class="line">    PyCodeObject *co;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    co = PyAST_CompileObject(mod, filename, flags, <span class="number">-1</span>, arena);</span><br><span class="line">    <span class="keyword">if</span> (co == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PySys_Audit(<span class="string">"exec"</span>, <span class="string">"O"</span>, co) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Py_DECREF(co);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = run_eval_code_obj(co, globals, locals);</span><br><span class="line">    Py_DECREF(co);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将python moduleParse成AST（调用<code>PyAST_CompileObject()</code>函数），再编译成Python的ByteCode，最后塞给<code>run_eval_code_obj()</code>函数进行执行。</p><p>基本上repl的执行流程就讲完了，有点困了，有（bu）时（xiang）间（nong）再细化补充，欢迎留言。</p><p>源码分析地比较粗糙，找到一片详细debug，介绍cpython中的编译执行流程的博客，见最后一片参考文章（Internals of CPython），写得比较详细，甚至还简单介绍了gdb的使用方式，很贴心。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/966138843228672" target="_blank" rel="noopener">Python解释器</a></p><p><a href="https://github.com/ipython/ipython/blob/master/IPython/core/interactiveshell.py" target="_blank" rel="noopener">interactiveshell.py</a></p><p><a href="https://github.com/python/cpython/blob/master/Modules/main.c" target="_blank" rel="noopener">Modules/main.c</a></p><p><a href="https://github.com/python/cpython/blob/master/Python/pythonrun.c" target="_blank" rel="noopener">Python/pythonrun.c</a></p><p><a href="https://hackmd.io/@xff9N3eQTLSL4Trq-6setg/ByMHBMjFe?type=view" target="_blank" rel="noopener">Internals of CPython</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;Python是一种解释型语言，通过解释器对代码进行逐行执行，一般的解释器也是这样实现，当然也存在一些优化方法，对代码进行JIT编译，提高执行
      
    
    </summary>
    
    
    
      <category term="Compiler" scheme="https://ChinoMars.github.io/tags/Compiler/"/>
    
      <category term="Python" scheme="https://ChinoMars.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>REPL技术分析——Swift REPL模式</title>
    <link href="https://chinomars.github.io/2020/02/07/REPL%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Swift-REPL%E6%A8%A1%E5%BC%8F/"/>
    <id>https://chinomars.github.io/2020/02/07/REPL%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Swift-REPL%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-02-07T08:45:43.000Z</published>
    <updated>2020-02-07T09:25:01.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h3><p>在IR层面支持REPL，提供swift解释器，swift提供了编译器runtime，提供基础的词法分析、语法分析、IR生成能力，并可基于llvm ir进行表达式eval，通过JIT的方式在解释器中支持REPL。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><p>头文件：<code>include/swift/Immediate/Immediate.h</code>，包含两个接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RunImmediately</span><span class="params">(CompilerInstance &amp;CI, <span class="keyword">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> IRGenOptions &amp;IRGenOpts, <span class="keyword">const</span> SILOptions &amp;SILOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SILModule&gt; &amp;&amp;SM)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runREPL</span><span class="params">(CompilerInstance &amp;CI, <span class="keyword">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">bool</span> ParseStdlib)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>RunImmediately方法用于基于<strong>SIL（Swift Intermediate Language）</strong>，立即Eval当前IR Module，相当于是解释器</li><li>runREPL方法提供给FrontendTool.cpp前端逻辑进行调用，作为REPL的main loop</li></ul></li><li><p>源码文件：Immediate.cpp</p></li></ol><p>实现几个功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">loadSwiftRuntime</span><span class="params">(ArrayRef&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; runtimeLibPaths)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tryLoadLibraries</span><span class="params">(ArrayRef&lt;LinkLibrary&gt; LinkLibraries,</span></span></span><br><span class="line"><span class="function"><span class="params">                      SearchPathOptions SearchPathOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                      DiagnosticEngine &amp;Diags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">linkLLVMModules</span><span class="params">(llvm::Module *Module,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;llvm::Module&gt; SubModule)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">autolinkImportedModules</span><span class="params">(ModuleDecl *M, <span class="keyword">const</span> IRGenOptions &amp;IRGenOpts)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swift::RunImmediately</span><span class="params">(CompilerInstance &amp;CI,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> ProcessCmdLine &amp;CmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> IRGenOptions &amp;IRGenOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> SILOptions &amp;SILOpts,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;SILModule&gt; &amp;&amp;SM)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>加载swift编译器runtime：swiftCore</li><li>llvm ir module间合并</li><li>import module的支持</li><li>RunImmediately：将input翻译成llvm ir，调用<code>llvm::ExecutionEngine</code>直接执行llvm ir</li></ul><ol start="3"><li>源码文件：REPL.cpp</li></ol><p>REPL的主函数，从Frontend.cpp进来，主要由一个读取用户input的main loop，对每个输入进行处理。依赖histedit的支持</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h3><p><a href="https://blog.csdn.net/weixin_43740680/article/details/98234795" target="_blank" rel="noopener">What’s REPL</a></p><p><a href="https://github.com/apple/swift/blob/master/lib/Immediate/Immediate.cpp" target="_blank" rel="noopener">Source Code Immediate.cpp</a></p><p><a href="https://github.com/apple/swift/blob/master/lib/Immediate/REPL.cpp" target="_blank" rel="noopener">Source Code REPL.cpp</a></p><p><a href="http://ftp.netbsd.org/pub/NetBSD/NetBSD-current/src/lib/libedit/histedit.h" target="_blank" rel="noopener">histedit.h: Line editor and history interface.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术路线&quot;&gt;&lt;a href=&quot;#技术路线&quot; class=&quot;headerlink&quot; title=&quot;技术路线&quot;&gt;&lt;/a&gt;技术路线&lt;/h3&gt;&lt;p&gt;在IR层面支持REPL，提供swift解释器，swift提供了编译器runtime，提供基础的词法分析、语法分析、IR生成能
      
    
    </summary>
    
    
    
      <category term="Compiler" scheme="https://ChinoMars.github.io/tags/Compiler/"/>
    
      <category term="Swift" scheme="https://ChinoMars.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo和github page搭建个人博客</title>
    <link href="https://chinomars.github.io/2020/01/29/%E5%9F%BA%E4%BA%8EHexo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://chinomars.github.io/2020/01/29/%E5%9F%BA%E4%BA%8EHexo%E5%92%8Cgithub-page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-01-29T11:46:47.000Z</published>
    <updated>2020-01-30T06:26:03.234Z</updated>
    
    <content type="html"><![CDATA[<p>倒腾过好几次个人主页，但个人原创文章并不多，总是要么在换模板的路上，要不就是在换框架的路上，终于乐此而疲了。这次换个人主页之后还是要静下心来多写文章才是。这篇文章用于答谢Hexo和Archer主题的作者，hexo是到目前为止用过的最好用的博客框架，archer主题模板是目前个人比较喜欢的一款模版。</p><p>废话不多说，按照个人习惯，分四段简单介绍下如何基于Hexo和Github Page搭建个人主页。</p><blockquote><p>本文不严格区分*nix系统和windows系统，所有命令均可在terminal或者gitbash中执行。</p></blockquote><h2 id="0x00-准备"><a href="#0x00-准备" class="headerlink" title="0x00 准备"></a>0x00 准备</h2><p>hexo是一个静态站点生成工具，集创建（初始化站点）、开发（指的是写博客）、发布博客文章功能于一体，十分方便。</p><p>搭建博客站点先准备以下平台的账号和开发环境：</p><ul><li><p>注册github账户，<a href="https://github.com/" target="_blank" rel="noopener">链接</a></p></li><li><p>安装git，并在github账户中配置sshkey：*nix系统一般自带git，windows系统安装gitbash，<a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载地址</a></p></li><li><p>配置sshkey：</p><ul><li><p>生成sshkey：*nix系统中打开terminal，windows系统中打开gitbash，参考<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">教程</a>，执行以下命令，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span> <span class="comment"># your_email@example.com替换为你注册github的邮箱，可以一直按回车生成默认的文件名，方便阅读后续的步骤</span></span><br></pre></td></tr></table></figure></li><li><p>执行以下命令，拷贝出你的public key，将屏幕中输出的公钥内容<code>ctrl+c</code>进行拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh/ &amp;&amp; cat id_rsa.pub <span class="comment"># 这里的id_rsa.pub为上一步生成的密钥对中的公钥</span></span><br></pre></td></tr></table></figure></li><li><p>打开github中配置sshkey的界面，<a href="https://github.com/settings/keys" target="_blank" rel="noopener">链接</a>，选择<code>New SSH key</code>，把拷贝的公钥配置上去即可。</p></li></ul></li><li><p>安装Nodejs，<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">下载地址</a>，安装成功后会同时安装好node和npm两个工具，并为npm配置国内源，例如配置淘宝源可以执行下述命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>安装hexo，执行下述命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g <span class="comment"># install hexo</span></span><br><span class="line">hexo -v <span class="comment"># check whether successfully installed</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="0x01-初始化站点"><a href="#0x01-初始化站点" class="headerlink" title="0x01 初始化站点"></a>0x01 初始化站点</h2><p>执行以下命令来初始化博客站点，会创建一个新的目录，以blog-dev为例，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog-dev</span><br></pre></td></tr></table></figure><p>待命令执行完毕，会新建一个blog-dev目录，进入该目录中，我们可以看到以下目录树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">blog-dev</span><br><span class="line">├── _config.yml        <span class="comment">#---------------- 站点配置文件</span></span><br><span class="line">├── node_modules       <span class="comment">#---------------- npm安装包本地保存目录</span></span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json       <span class="comment">#---------------- 依赖包配置文件</span></span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span>             <span class="comment">#---------------- 博客文章保存目录</span></span><br><span class="line">└── themes             <span class="comment">#---------------- 博客主题保存目录</span></span><br></pre></td></tr></table></figure><p>此时，进入到blog-dev目录，可以执行hexo的相关参数及命令，可以进行站点的管理，简单介绍如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo generate <span class="comment"># 生成网站静态文件</span></span><br><span class="line">hexo server <span class="comment"># 启动本地调试模式，默认可以打开localhost:4000查看网站效果</span></span><br><span class="line">hexo deploy <span class="comment"># 发布到GitHub Page，第0x11节会具体介绍</span></span><br></pre></td></tr></table></figure><p>hexo还有一个非常方便的点是主题套用十分方便，将想要的模板下载下来，放到themes目录下，然后修改_config.yml文件中的theme字段，改为下载下来的主题目录名即可。主题可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方网站下载</a>，也可以自行从各种渠道获取。</p><h2 id="0x10-创建github-page"><a href="#0x10-创建github-page" class="headerlink" title="0x10 创建github page"></a>0x10 创建github page</h2><p>本节内容大家应该都比较熟悉，创建作为个人主页用的github page，必须将仓名命名为username.github.com，经过测试，仓名中的username与你的github账号名可以不区分大小写。</p><p>这部分教程我想偷懒跳过了，可以自行查看<a href="https://pages.github.com/" target="_blank" rel="noopener">官方教程</a>。</p><h2 id="0x11-预览和发布"><a href="#0x11-预览和发布" class="headerlink" title="0x11 预览和发布"></a>0x11 预览和发布</h2><p>在blog-dev目录下执行<code>hexo new &#39;博客标题&#39;</code>即可创建一篇新的博客，使用markdown语法进行编辑。</p><p>编辑完毕之后，执行下述命令，可以启动一个本地的临时服务器进行预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 启动本地预览服务</span></span><br></pre></td></tr></table></figure><p>在浏览器中打开<code>localhost:4000</code>，即可预览你的博客。</p><p>配置blog-dev的发布路径，编辑blog-dev/_config.yml文件，一般在文件末尾，有一个deploy字段，把第三节创建的github page仓库路径配置上去即可，如果deploy字段下只有一个type，则手动添加其他字段（注意yml文件遵从yaml格式缩紧）。例如我的配置就是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>                                                                                                          </span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/ChinoMars/chinomars.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>依次执行下述命令，即可发布你的静态站点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">hexo generate <span class="comment"># 生成站点的静态文件</span></span><br><span class="line">hexo deploy <span class="comment"># 自动push到github page所在的master分支，进行发布</span></span><br></pre></td></tr></table></figure><p>最后，可以打开网址：<code>https://username.github.io</code>即可查看个人的站点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;倒腾过好几次个人主页，但个人原创文章并不多，总是要么在换模板的路上，要不就是在换框架的路上，终于乐此而疲了。这次换个人主页之后还是要静下心来多写文章才是。这篇文章用于答谢Hexo和Archer主题的作者，hexo是到目前为止用过的最好用的博客框架，archer主题模板是目前
      
    
    </summary>
    
    
    
      <category term="小白" scheme="https://ChinoMars.github.io/tags/%E5%B0%8F%E7%99%BD/"/>
    
  </entry>
  
</feed>
